package org.kainos.ea.team2.api;

import io.fusionauth.jwt.JWTUtils;
import io.fusionauth.jwt.Signer;
import io.fusionauth.jwt.Verifier;
import io.fusionauth.jwt.domain.JWT;
import io.fusionauth.jwt.hmac.HMACSigner;
import io.fusionauth.jwt.hmac.HMACVerifier;
import org.kainos.ea.team2.cli.BasicCredentials;
import org.kainos.ea.team2.cli.HashedPassword;
import org.kainos.ea.team2.cli.UserRole;
import org.kainos.ea.team2.client.AuthenticationException;
import org.kainos.ea.team2.client.IValidator;
import org.kainos.ea.team2.client.ValidationException;
import org.kainos.ea.team2.db.IAuthenticationSource;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.spec.KeySpec;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.Arrays;

/**
 * Implements the authentication service defined by the interface.
 */
public class AuthenticationService implements IAuthenticationService {
    /**
     * The hashing algorithm to use.
     */
    private static final String HASH_ALG = "PBKDF2WithHmacSHA512";

    /**
     * The length of any keys generated by the service.
     */
    private static final int KEY_LENGTH = 512;

    /**
     * The length of any salt generated by the service.
     */
    private static final int SALT_LENGTH = 16;

    /**
     * Implementation of an authentication source.
     */
    private final IAuthenticationSource authSource;

    /**
     * A signer for JWTs.
     */
    private final Signer jwtSigner;

    /**
     * A verifier for JWTs.
     */
    private final Verifier jwtVerifier;

    /**
     * Validates basic credentials.
     */
    private final IValidator<BasicCredentials> validator;


    /**
     * Creates a new instance of this service.
     * @param authSource The source to pull credentials from.
     * @param jwtSecret The secret used to sign and verify JWTs
     * @param validator the validator to use for credentials.
     */
    public AuthenticationService(
            final IAuthenticationSource authSource,
            final String jwtSecret,
            final IValidator<BasicCredentials> validator) {
        if (jwtSecret == null) {
            throw new IllegalArgumentException("JWT_SECRET NOT SET");
        }

        this.authSource = authSource;
        this.jwtSigner = HMACSigner.newSHA256Signer(jwtSecret);
        this.jwtVerifier = HMACVerifier.newVerifier(jwtSecret);
        this.validator = validator;
    }

    /**
     * Re-generates a password hash given the passed parameters.
     * Method called in authenticate method in Auth Service class.
     * @param password the password to hash.
     * @param salt the salt used in the hash.
     * @param iterations the number of iterations used in the hash.
     * @return byte[] representing the hash.
     * @throws AuthenticationException throw if hashing fails
     */
    private byte[] getPasswordHash(
            final String password,
            final byte[] salt,
            final int iterations)
            throws AuthenticationException {

      try {
          final char[] passwordChars = password.toCharArray();
          KeySpec spec =
                  new PBEKeySpec(passwordChars, salt, iterations, KEY_LENGTH);
          SecretKeyFactory factory = SecretKeyFactory.getInstance(HASH_ALG);

          return factory.generateSecret(spec).getEncoded();
      } catch (Exception e) {
          throw new AuthenticationException(e.getMessage());
      }
    }

    /**
     * Attempts to generate a JWT with the credential provided.
     * @param credentials the credentials to authenticate.
     * @return JWT if successful, null if failed.
     * @throws AuthenticationException Thrown on server error.
     * @throws ValidationException Thrown on validation error
     */
    @Override
    public JWT authenticate(
            final BasicCredentials credentials)
            throws AuthenticationException, ValidationException {

        // pass entered credentials into validator class.
        // returns null if data entered in both fields,
        // returns a string if one/both fields are null or empty
        String error = validator.validate(credentials);
        if (error != null) {
            // if string returned from validator, throw exception
            System.err.println("credentials invalid");
            throw new ValidationException(error);

        }

        // get the hashed password for
        // user with entered name (see DBAuthenticationSource)
        HashedPassword hashedPassword =
                authSource.getHashedPasswordForUser(credentials.getUsername());

        // returns null if nothing returned from db i.e. username wrong
        if (hashedPassword == null) {
            return null;
        }

        // re hash the provided password and add the existing salt
        String password = credentials.getPassword();
        byte[] salt = hashedPassword.getSalt();
        int iterations = hashedPassword.getIterations();
        byte[] credentialHash = getPasswordHash(password, salt, iterations);

        byte[] passwordHash = hashedPassword.getHashedPassword();

        // if provided password does not equal password in db, return null
        if (!Arrays.equals(credentialHash, passwordHash)) {
            return null;
        }

        // get role of given user from db (see DBAuthenticationSource)
        UserRole role = authSource.getRoleForUser(credentials.getUsername());
        if (role == null) {
            throw new AuthenticationException("Could not get role for user");
        }

        // if no null returned yet, username and password
        // are good and user has a role -> create jwt token
        return new JWT()
            .setIssuer("org.kainos.ea")
            .setIssuedAt(ZonedDateTime.now(ZoneOffset.UTC))
                // subject is current credentials
            .setSubject(credentials.getUsername())
            .addClaim("role", role.toString()) // role of user
            .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).plusDays(1));
    }

    /**
     * Checks if the encoded JWT passed was issued by this server.
     * @param jwt the JWT to validate.
     * @return true if valid, false if not.
     * @throws AuthenticationException thrown if validation was not possible
     */
    @Override
    public boolean validate(final String jwt) throws AuthenticationException {
        try {
            JWT userJWT = JWT.getDecoder().decode(jwt, jwtVerifier);
            return userJWT != null;
        } catch (Exception e) {
            throw new AuthenticationException(e.getMessage());
        }
    }

    /**
     * Attempts to sign and encode a JWT.
     * @param jwt the JWT to sign
     * @return the signed, encoded JWT
     * @throws AuthenticationException thrown if signing was not possible
     */
    @Override
    public String sign(final JWT jwt) throws AuthenticationException {
        try {
            // call to JWT class (java) to encode and sign jwt
            return JWT.getEncoder().encode(jwt, jwtSigner);
        } catch (Exception e) {
            throw new AuthenticationException(e.getMessage());
        }
    }

    /**
     * Returns the role assigned to the passed JWT token.
     * @param token the encoded token to check
     * @return the role the token has
     */
    public static UserRole getTokenRole(final String token) {
        JWT userJWT = JWTUtils.decodePayload(token);
        String role = String.valueOf(userJWT.getAllClaims().get("role"));

        if (role == null) {
            return null;
        }

        return UserRole.valueOf(role);
    }
}
