package org.kainos.ea.team2.api;

import io.fusionauth.jwt.Signer;
import io.fusionauth.jwt.Verifier;
import io.fusionauth.jwt.domain.JWT;
import io.fusionauth.jwt.hmac.HMACSigner;
import io.fusionauth.jwt.hmac.HMACVerifier;
import org.kainos.ea.team2.cli.BasicCredentials;
import org.kainos.ea.team2.cli.HashedPassword;
import org.kainos.ea.team2.cli.UserRole;
import org.kainos.ea.team2.client.AuthenticationException;
import org.kainos.ea.team2.client.IValidator;
import org.kainos.ea.team2.client.ValidationException;
import org.kainos.ea.team2.db.IAuthenticationSource;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.spec.KeySpec;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.Arrays;

/**
 * Implements the authentication service defined by the interface.
 */
public class AuthenticationService implements IAuthenticationService {
    /**
     * The hashing algorithm to use.
     */
    private static final String HASH_ALG = "PBKDF2WithHmacSHA512";

    /**
     * The length of any keys generated by the service.
     */
    private static final int KEY_LENGTH = 512;

    /**
     * The length of any salt generated by the service.
     */
    private static final int SALT_LENGTH = 16;

    /**
     * Implementation of an authentication source.
     */
    private final IAuthenticationSource authSource;

    /**
     * A signer for JWTs.
     */
    private final Signer jwtSigner;

    /**
     * A verifier for JWTs.
     */
    private final Verifier jwtVerifier;

    /**
     * Validates basic credentials.
     */
    private final IValidator<BasicCredentials> validator;


    /**
     * Creates a new instance of this service.
     * @param authSource The source to pull credentials from.
     * @param jwtSecret The secret used to sign and verify JWTs
     * @param validator the validator to use for credentials.
     */
    public AuthenticationService(
            final IAuthenticationSource authSource,
            final String jwtSecret,
            final IValidator<BasicCredentials> validator) {
        if (jwtSecret == null) {
            throw new IllegalArgumentException("JWT_SECRET NOT SET");
        }

        this.authSource = authSource;
        this.jwtSigner = HMACSigner.newSHA256Signer(jwtSecret);
        this.jwtVerifier = HMACVerifier.newVerifier(jwtSecret);
        this.validator = validator;
    }

    /**
     * Re-generates a password hash given the passed parameters.
     * @param password the password to hash.
     * @param salt the salt used in the hash.
     * @param iterations the number of iterations used in the hash.
     * @return byte[] representing the hash.
     * @throws AuthenticationException throw if hashing fails
     */
    private byte[] getPasswordHash(
            final String password,
            final byte[] salt,
            final int iterations)
            throws AuthenticationException {

      try {
          final char[] passwordChars = password.toCharArray();
          KeySpec spec =
                  new PBEKeySpec(passwordChars, salt, iterations, KEY_LENGTH);
          SecretKeyFactory factory = SecretKeyFactory.getInstance(HASH_ALG);

          return factory.generateSecret(spec).getEncoded();
      } catch (Exception e) {
          throw new AuthenticationException(e.getMessage());
      }
    }

    /**
     * Attempts to generate a JWT with the credential provided.
     * @param credentials the credentials to authenticate.
     * @return JWT if successful, null if failed.
     * @throws AuthenticationException Thrown on server error.
     * @throws ValidationException Thrown on validation error
     */
    @Override
    public JWT authenticate(
            final BasicCredentials credentials)
            throws AuthenticationException, ValidationException {

        String error = validator.validate(credentials);
        if (error != null) {
            throw new ValidationException(error);
        }

        HashedPassword hashedPassword =
                authSource.getHashedPasswordForUser(credentials.getUsername());

        if (hashedPassword == null) {
            return null;
        }

        //re hash the provided password and add the existing salt
        String password = credentials.getPassword();
        byte[] salt = hashedPassword.getSalt();
        int iterations = hashedPassword.getIterations();
        byte[] credentialHash = getPasswordHash(password, salt, iterations);

        byte[] passwordHash = hashedPassword.getHashedPassword();

        if (!Arrays.equals(credentialHash, passwordHash)) {
            return null;
        }

        UserRole role = authSource.getRoleForUser(credentials.getUsername());
        if(role == null){
            throw new AuthenticationException("Could not get role for user");
        }

        return new JWT()
            .setIssuer("org.kainos.ea")
            .setIssuedAt(ZonedDateTime.now(ZoneOffset.UTC))
            .setSubject(credentials.getUsername())
            .addClaim("role",role.toString())
            .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).plusDays(1));
    }

    /**
     * Checks if the encoded JWT passed was issued by this server.
     * @param jwt the JWT to validate.
     * @return true if valid, false if not.
     */
    @Override
    public boolean validate(final String jwt) {
        JWT userJWT = JWT.getDecoder().decode(jwt, jwtVerifier);
        return userJWT != null;
    }

    /**
     * Attempts to sign and encode a JWT.
     * @param jwt the JWT to sign
     * @return the signed, encoded JWT
     */
    @Override
    public String sign(final JWT jwt) {
        return JWT.getEncoder().encode(jwt, jwtSigner);
    }

    /**
     * Checks if the token passed has the role.
     * Does not check if the token is valid or
     * has been generated by this application.
     * @param token the token to check
     * @param role the role to check for
     * @return true if the token has the role false if not
     */
    public static boolean doesTokenHaveRole(String token, UserRole role){
        JWT userJWT = JWT.getDecoder().decode(token);
        return userJWT.getAllClaims().get("role").equals(role.toString());
    }
}
