package org.kainos.ea.team2.api;

import io.fusionauth.jwt.Signer;
import io.fusionauth.jwt.Verifier;
import io.fusionauth.jwt.domain.JWT;
import io.fusionauth.jwt.hmac.HMACSigner;
import io.fusionauth.jwt.hmac.HMACVerifier;
import org.kainos.ea.team2.cli.BasicCredentials;
import org.kainos.ea.team2.cli.HashedPassword;
import org.kainos.ea.team2.client.AuthenticationException;
import org.kainos.ea.team2.db.IAuthenticationSource;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.Arrays;

/**
 * Implements the authentication service defined by the interface.
 */
public class AuthenticationService implements IAuthenticationService {
    /**
     * The hashing algorithm to use.
     */
    private static final String HASH_ALG = "PBKDF2WithHmacSHA512";

    /**
     * The length of any keys generated by the service.
     */
    private static final int KEY_LENGTH = 512;

    /**
     * The length of any salt generated by the service.
     */
    private static final int SALT_LENGTH = 16;

    /**
     * Implementation of an authentication source.
     */
    private final IAuthenticationSource authSource;

    /**
     * A signer for JWTs.
     */
    private final Signer jwtSigner;

    /**
     * A verifier for JWTs.
     */
    private final Verifier jwtVerifier;


    /**
     * Creates a new instance of this service.
     * @param authSource The source to pull credentials from.
     * @param jwtSecret The secret used to sign and verify JWTs
     */
    public AuthenticationService(
            final IAuthenticationSource authSource,
            final String jwtSecret) {
        this.authSource = authSource;
        this.jwtSigner = HMACSigner.newSHA256Signer(jwtSecret);
        this.jwtVerifier = HMACVerifier.newVerifier(jwtSecret);
    }

    /**
     * Re-generates a password hash given the passed parameters.
     * @param password the password to hash.
     * @param salt the salt used in the hash.
     * @param iterations the number of iterations used in the hash.
     * @return byte[] representing the hash.
     * @throws NoSuchAlgorithmException Thrown if algorithm doesn't exist.
     * @throws InvalidKeySpecException Thrown if hash generation fails.
     */
    private byte[] getPasswordHash(
            final String password,
            final byte[] salt,
            final int iterations)
            throws NoSuchAlgorithmException, InvalidKeySpecException {

        final char[] passwordChars = password.toCharArray();
        KeySpec spec =
                new PBEKeySpec(passwordChars, salt, iterations, KEY_LENGTH);
        SecretKeyFactory factory = SecretKeyFactory.getInstance(HASH_ALG);

        return factory.generateSecret(spec).getEncoded();
    }

    /**
     * Attempts to generate a JWT with the credential provided.
     * @param credentials the credentials to authenticate.
     * @return JWT if successful, null if failed.
     * @throws AuthenticationException Thrown on validation error.
     */
    @Override
    public JWT authenticate(
            final BasicCredentials credentials)
            throws AuthenticationException {
        HashedPassword hashedPassword =
                authSource.getHashedPasswordForUser(credentials.getUsername());

        if (hashedPassword == null) {
            return null;
        }

        //re hash the provided password and add the existing salt
        byte[] credentialHash = null;
        try {
            String password = credentials.getPassword();
            byte[] salt = hashedPassword.getSalt();
            int iterations = hashedPassword.getIterations();
            credentialHash = getPasswordHash(password, salt, iterations);
        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw new AuthenticationException(e.getMessage());
        }

        byte[] pwordHash = hashedPassword.getHashedPassword();

        if (!Arrays.equals(credentialHash, pwordHash)) {
            return null;
        }

        return new JWT()
            .setIssuer("org.kainos.ea")
            .setIssuedAt(ZonedDateTime.now(ZoneOffset.UTC))
            .setSubject(credentials.getUsername())
            .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).plusDays(1));
    }

    /**
     * Checks if the encoded JWT passed was issued by this server.
     * @param jwt the JWT to validate.
     * @return true if valid, false if not.
     */
    @Override
    public boolean validate(final String jwt) {
        JWT userJWT = JWT.getDecoder().decode(jwt, jwtVerifier);
        return userJWT != null;
    }

    /**
     * Attempts to sign and encode a JWT.
     * @param jwt the JWT to sign
     * @return the signed, encoded JWT
     */
    @Override
    public String sign(final JWT jwt) {
        return JWT.getEncoder().encode(jwt, jwtSigner);
    }
}
